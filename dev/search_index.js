var documenterSearchIndex = {"docs":
[{"location":"ransac/#Efficient-RANSAC-1","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"","category":"section"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"This is a longer description of the RANSAC paradigm, shamelessly copied from my master's thesis (still based on Schnabel2007).","category":"page"},{"location":"api/#Public-API-1","page":"API","title":"Public API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Note, that not all exported functions are considered as part of the public API.","category":"page"},{"location":"api/#Representing-a-point-cloud-1","page":"API","title":"Representing a point cloud","text":"","category":"section"},{"location":"api/#Parameters-1","page":"API","title":"Parameters","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"With the help of Parameters.jl it's easy to parameterize the algorithm. The RANSACParameters type collects all the parameters, though its fields are subject to change, the current fields and default values are listed below.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"@with_kw struct RANSACParameters{R<:Real} @deftype R\n    ϵ_plane = 0.3\n    α_plane = deg2rad(5)\n\n    ϵ_sphere = 0.3\n    α_sphere = deg2rad(5)\n\n    ϵ_cylinder = 0.3\n    α_cylinder = deg2rad(5)\n\n    ϵ_cone = 0.3\n    α_cone = deg2rad(5)\n    # filter those cones, whose opening angle is less than `minconeopang` radians\n    minconeopang = deg2rad(2)\n\n    ϵ_torus = 0.3\n    α_torus = deg2rad(5)\n\n    # number of points to be sampled (length of a minimal subset)\n    drawN::Int = 3; @assert drawN>2\n    # number of minimal sets sampled in one iteration\n    minsubsetN::Int = 15; @assert minsubsetN>0\n    # probability of detection\n    prob_det = 0.9\n    # minimal shape size\n    τ::Int = 900\n    # maximum number of iteration\n    itermax::Int = 1000\n    # if the number of enabled points fall under `leftover`,\n    # the iteration terminates\n    leftovers::Int = 1\n\n    # threshold of two vectors being parallel (in degrees)\n    parallelthrdeg = 1\n    # threshold of points being collinear\n    collin_threshold = 0.2\n    # parameter in sphere fitting\n    sphere_par = 0.02\n\n    # shapes that are fitted to the point cloud\n    shape_types::Array{Symbol,1} = [:sphere, :plane, :cylinder, :cone]\nend","category":"page"},{"location":"#RANSAC.jl-1","page":"Home","title":"RANSAC.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package implements the efficient RANSAC algorithm for point clouds. Paper can be found here: Schnabel2007.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"R. Schnabel, R. Wahl, R. Klein \t\"Efficient RANSAC for Point-Cloud Shape Detection\", \tin Computer Graphics Forum, Vol. 26, No. 2, pages 214-226, \tBlackwell Publishing, June 2007","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A full page (Efficient RANSAC) is dedicated to describe the algorithm and to help to understand the parameters. If something is not clear, please open an issue or check the original paper.","category":"page"},{"location":"#Short-description-1","page":"Home","title":"Short description","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The input of the algorithm is a point cloud of size N with points and associated surface normals. The output is a set of primitive shapes with corresponding sets of points, and the rest of the points that do not belong to any primitives. Primitive shapes can be: plane, sphere, cylinder, cone and torus (though torus is not implemented yet).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In every iteration, new shape candidates are created by fitting primitives to randomly sampled minimal sets. Every shape primitive is generated for every minimal set and the valid ones are continuously collected in set C. Then every candidate is scored and the one with the highest score is considered the best. A candidate is only extracted if the probability (p_t) that no better candidates are in C is high enough. If the best candidate is chosen to be extracted, its points are removed from the point cloud, and every other candidate that has a removed point is also deleted from C. The iteration continues until the probability that every at least tau sized shape is found is larger than a parameter threshold. The score of a candidate is defined by the number of compatible points. A point is compatible if it is in the epsilon band of the shape, and its normal does not deviate from the surface normal more than an alpha angle. Also, only those points are considered that count towards the largest connecting component in the parameter space bitmap of the shape.","category":"page"},{"location":"#Quick-tour-1","page":"Home","title":"Quick tour","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Install the package:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add https://github.com/cserteGT3/RANSAC.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Get an example point cloud. Use your own, or download a public dataset (for example the one used in Schnabel2009, read more about on the Example page)\nYou can use MeshIO.jl to load models.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using FileIO\nm = load(\"testm.obj\")\nusing RANSAC\npc = PointCloud(m, 2)\nrparams = RANSACParameters{Float64}()","category":"page"},{"location":"#Differences-from-the-reference-implementation-1","page":"Home","title":"Differences from the reference implementation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"no bitmap\nseparate parameters for each shape\nno tori","category":"page"},{"location":"example/#Example-1","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"This page guides you through the use of RANSAC.jl. A public dataset is used, that was published by Schnabel et al. and is accessible here.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"R. Schnabel, P. Degener, R. Klein \"Completion and Reconstruction with Primitive Shapes\", in Computer Graphics Forum (Proc. of Eurographics), Vol. 28, No. 2, pages 503-512","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"Read the algorithm description here to get a full understanding of the algorithm and its parameters.","category":"page"},{"location":"example/#Loading-the-data-1","page":"Example","title":"Loading the data","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"As MeshIO and other softwares had troubles opening the _input.obj files, I used MeshLab to open them and export to non-binary encoded PLY.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> using FileIO\n\njulia> m = load(\"fandisk_input.obj\")\nHomogenousMesh(\n    faces: 17513xGeometryTypes.Face{3,GeometryTypes.OffsetInteger{-1,UInt32}},     vertices: 8935xGeometryTypes.Point{3,Float32},     normals: 8935xGeometryTypes.Normal{3,Float32}, )","category":"page"},{"location":"example/#Constructing-a-PointCloud-1","page":"Example","title":"Constructing a PointCloud","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"Currently the package only handles vectors of Float64.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> using RANSAC\n\njulia> pc = PointCloud(m.vertices, m.normals, 8)\nPointCloud{Array{StaticArrays.SArray{Tuple{3},Float64,1,3},1},Array{Array{Int64,1},1},Array{Float64,1}}\nPointCloud of size 8935 & 8 subsets","category":"page"},{"location":"example/#Set-the-parameters-1","page":"Example","title":"Set the parameters","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"Check the Short description and Parameters pages to understand the parameters.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> p = RANSACParameters{Float64}();\n\njulia> p = setalphas(p, deg2rad(10));\n\njulia> p = setepsilons(p, 0.05);\n\njulia> p = RANSACParameters(p, τ=50, itermax=100_000);","category":"page"},{"location":"example/#Run!-1","page":"Example","title":"Run!","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"The ransac() function runs the iteration.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> _, extr, _ = ransac(pc, p, true, reset_rand=true);","category":"page"},{"location":"example/#See-the-results-1","page":"Example","title":"See the results","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"There's the RANSACVisualizer package that provides a few utility functions to check the results.","category":"page"}]
}
