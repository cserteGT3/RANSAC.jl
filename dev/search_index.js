var documenterSearchIndex = {"docs":
[{"location":"ransac/#Efficient-RANSAC-1","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"","category":"section"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"This is a longer description of the RANSAC paradigm, shamelessly copied from my master's thesis (still based on Schnabel2007).","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"The Short algorithm description section introduces the concept and the steps of the algorithm (which are also shown in the following picture). Hereby we describe the steps in more details. (Image: )","category":"page"},{"location":"ransac/#Primitive-fitting-1","page":"Efficient RANSAC","title":"Primitive fitting","text":"","category":"section"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Considered shapes are planes, spheres, cylinders, cones and tori. For these methods not only the points p_1 p_2 p_3 are needed but the corresponding surface normals n_1 n_2 n_3, as well. If normal information is not available, there are algorithms to approximate it (PCA for example). With the presence of normals, the shapes can be approximated from only one or two samples. However, an additional sample can be used to immediately verify a candidate, and thus reduce the number of many relatively low scored shapes.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Plane: In the case of planes, three points define a plane and their normals are used to validate the fit. A candidate is only accepted if the deviations of the three normals and the fitted normal are less than a predefined angle alpha.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Sphere: A sphere is fully defined by two points and their normals. Of course, in the presence of noise, the two lines determined by the point-normal pairs do not meet at the centre of the sphere, therefore the midpoint of the shortest line segment between the two lines is used as a centre. Then the mean of the distance from the centre to the two points is taken as the sphere radius. The sphere is rejected if not all three points are in the epsilon band of the sphere surface, or the normals deviate by more than an alpha angle from the computed normals.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Cylinder: For cylinders, the cross product of two normals gives the axis of the cylinder. A centre point can be computed by projecting the two lines (determined by the point-normal pairs) onto the plane defined by the axis and taking their intersection. The radius of the circle is then set to the distance of the centre and one point on that plane. As always, the compatibility of all three points is tested.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Cone: Although the cone is defined by two points and normals, all three are used for its recognition. The apex (c) is found by intersecting the three planes defined by the point-normal pairs. The axis (a) is given by the normal of the plane defined by the three points c+fracp_1-cp_1-c ldots c+fracp_3-cp_3-c. The opening angle is given as omega=fracsum_i arccos((p_i-c)cdot a)3. The cone is also verified by compatibility before becoming a candidate.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Torus: as the torus was not implemented in the scope of this thesis, the reader is guided to Section 4.1 in Schnabel2007.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"The original paper does not elaborate more on the direction of the normals, but while implementing we took some notes that worth sharing. First let us introduce the terms positive and negative shapes. A positive shape means that the normals point from the centre or axis of the shape towards outside and of course negative shape means the opposite. When the compatibility is determined we must take the positivity/negativity into account, which means that all the normals should similarly be positive or negative. If they are different, the candidate is discarded. This is mainly a noise filtering step to ensure the appropriate shapes, but one may use this information to accelerate the CSG-tree reconstruction with additional a priori information.","category":"page"},{"location":"ransac/#Computational-complexity-1","page":"Efficient RANSAC","title":"Computational complexity","text":"","category":"section"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"The complexity of the algorithm is dominated by two major factors: the number of minimal sets that are drawn, and the cost of evaluating the score for every candidate shape. Let P be a point cloud consisting of N points and therein a shape psi of size n. Let k denote the minimum number of points required to define the shape, also called a minimal set. If we assume that every k points will result in an appropriate candidate, the probability of detecting psi in a single pass:","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"P(n) =  binomnk bigg binomNk approx   bigg( fracnN  bigg)^k","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"The probability of finding the candidate in the first s samples (drawing a new minimal set s times) equals to the probability of the complementary of s consecutive failures:","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"P(ns) =  1 - (1 - P(n))^s","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"The first two equations will be used later to calculate the extraction and termination criteria. After a short deduction, we can conclude that the asymptotic complexity of the RANSAC algorithm is","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Oleft(frac1P(n)Cright)","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"where C denotes the cost of evaluating the cost function.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"To summarize the equations: the size of the minimal set should be as small as possible, and a good sampling strategy is crucial, as the runtime complexity is directly linked to the success rate of finding good sample sets.","category":"page"},{"location":"ransac/#Sampling-1","page":"Efficient RANSAC","title":"Sampling","text":"","category":"section"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"As shapes are local phenomena, the smaller the distance between two points, the higher the probability that they belong to the same shape. This should be exploited during sampling. To establish spatial proximity, an octree data structure is used[1]. The first sample of a minimal set is chosen randomly from the entire point cloud. Then an octree cell is chosen which includes the selected point and rest of the points (k-1 pcs.) are drawn randomly from this cell.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Selection of the proper octree level is an essential part of the sampling strategy. Of course, we would like to choose the level so that the probability of a \"good cell\" is as high as possible. Therefore the cell is chosen from a level according to a non-uniform distribution that reflects the likelihood of the respective level to contain a good cell. The probability P_l of a level l is initialized with P_l=frac1d where d is the depth of the octree. Then for every level, the score (sigma_l) of previously scored candidates that originate from the corresponding level is summed and the distribution is updated:","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"hatP_l = xfracsigma_lw P_l + (1-x)frac1d","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"where w = sum_i=1^d fracsigma_iP_i. During the iteration, the distribution is continuously changing as more and more shapes are extracted from the point cloud. Setting x=09 ensures that 10 of the samples are always uniformly distributed among the levels. This enables the sampling algorithm to handle the changing importance of levels as points are removed from the point cloud. In one iteration of the RANSAC algorithm, not only one but t number of minimal sets are sampled. This is because sampling is computationally cheap compared to the rest of the iteration, and there are cases when no primitives fit the minimal set.","category":"page"},{"location":"ransac/#Score-1","page":"Efficient RANSAC","title":"Score","text":"","category":"section"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"The sigma score measures the quality of a given shape candidate. The score is equal to the number of compatible point-normal pairs. A point is compatible if it satisfies all the following requirements:","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"It must be in the epsilon radius band of the surface of the candidate.\nThe normal must not deviate from the surface normal at the point more than an alpha angle.\nThe point must be part of the largest connected component in the parameter space bitmap of the shape.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"As mentioned earlier when the normals are compared the positivity/negativity is also taken into account.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"The connected component criterion is a noise filtering step, however, in our implementation it is not considered. Based on our experiments, synthetic tests work without the bitmapping step, but of course, when this method is applied for real-world measurements, it is certainly needed. Our experiences have also shown that the algorithm is easier to fine-tune if there are separate epsilon and alpha parameters for every primitive type (i.e. epsilon_sphere, alpha_sphere, epsilon_plane, etc.).","category":"page"},{"location":"ransac/#Score-computing-1","page":"Efficient RANSAC","title":"Score computing","text":"","category":"section"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"The second major performance factor of the RANSAC algorithm is evaluating the score of the candidates. A naive implementation could be that we compute the compatibility of all the points, but it is not reasonable for large point clouds. At this stage of the algorithm, we are not interested in all the points that correspond to a candidate, but we would like to determine which shape consists of the most points. Therefore the computational cost can be reduced if the overall score is inferred from the score calculated for a smaller subset.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"The point cloud is partitioned into r number of disjoint random subsets: mathcalP=mathcalS_1    mathcalS_r. When the score is calculated, the candidate is scored only against the first subset (denoted by sigma_mathcalS_1). From this value, an approximation is given for the complete point cloud (sigma_p) using the well-known induction from inferential statistics:","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"hatsigma_mathcalP(psi) = -1- xi (-2-mathcalS_1 -2-mathcalP -1-sigma_mathcalS_1(psi))","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"where","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"xi (Nxn) = fracxn pm sqrtfracxn(N-x)(N-n)N-1N","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"is the mean plus/minus the standard deviation of the hypergeometric distribution. The result of the approximation is a confidence interval ab that gives a range of likely values of the exact score. The one with the largest expected value E=(a+b)2 is considered the best shape. Of course, if the confidence interval of the best one intersects with other intervals we cannot be sure that the best is really the best. Therefore further refinement – evaluation of the score for more subsets – is needed. This part is not implemented in the scope of this thesis, corresponding equations and methodology can be found in Section 4.5.1 of Schnabel2007. This scoring method has some additional effects on the way bitmaps are generated, these aspects are also described in the paper.","category":"page"},{"location":"ransac/#Termination-and-extraction-conditions-1","page":"Efficient RANSAC","title":"Termination and extraction conditions","text":"","category":"section"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Two important questions have not been addressed yet: how it is decided when to extract the best candidate (psi_m) and when to terminate the iteration. We aim to minimize the likelihood to extract a candidate that is not the best, therefore, we track the probability P(psi_ms) where s denotes the number of candidates that have already been drawn. P(psi_ms) is the likelihood that after drawing s candidates psi_m is the best. If it is higher than a threshold (p_t) we conclude that there is a low chance that we have overlooked a better candidate, and extract psi_m. The termination condition is similar, P(taus) is observed, where tau denotes a parameter, the minimum size of the shapes.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Implementation of these conditions seems straightforward, but based on the paper it is not clear what s exactly denotes. It can mean two things:","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"The number of candidates that are in set C at that given iteration.\nThe number of minimal sets that have been drawn. At the i-th iteration, this equals to i cdot t.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Based on our experiments, the first results in bad performance, because it takes many iterations to collect enough candidates to increase P(psi_ms) and extract the shapes. When using the second one, s increases fast, therefore candidates are quickly extracted, however, for the same reason, the algorithm might terminate too early. In this case, one must pay attention to the minimal shape size (tau), as larger values may cause early termination.","category":"page"},{"location":"ransac/#Extraction-1","page":"Efficient RANSAC","title":"Extraction","text":"","category":"section"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"When the best candidate is selected for extraction, refitting is executed before it is finally accepted. In the paper it is done as follows: a least-square fit is calculated to all compatible points that are within 3epsilon distance from the shape. This is another noise filtering step that optimizes the geometric error of the shape. Then the shape is extracted, the candidate is removed from set C, and its corresponding points are removed from the point cloud. Also, those candidates that have points removed are marked as invalid, and also deleted. In our implementation least-square fitting is not used, only the compatible points are searched in the whole point cloud.","category":"page"},{"location":"ransac/#Summary-of-parameters-1","page":"Efficient RANSAC","title":"Summary of parameters","text":"","category":"section"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"The following table summarizes the different parameters and annotations of the RANSAC algorithm. Only those parameters are listed that are described in the thesis.","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"Parameter Description Suggested value (Schnabel2007)\nmathcalP Input point cloud. -\nN Size of the input point cloud. -\nC Collection of shape candidates. -\np_t Probability threshold. 99\ntau Minimum size of shape candidates. -\nepsilon_prim Compatibility parameter for distance. -\nalpha_prim Compatibility parameter for angle of the normals. -\nk Size of the sampled minimal set. 3 or 4\ns Number of candidates at the given iteration. -\nd Octree depth. -\nsigma_l Sum of scores of shapes generated from octree level l. -\nP_l Likelihood that level l contains a good cell. -\nt Number of sampled minimal sets in one iteration. -\nr Number of subsets. -\nhatsigma_mathcalP(psi) Approximate score of shape psi. -","category":"page"},{"location":"ransac/#","page":"Efficient RANSAC","title":"Efficient RANSAC","text":"[1]: An octree is a tree data structure in which each internal node has exactly eight children.","category":"page"},{"location":"api/#Public-API-1","page":"API","title":"Public API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Note, that not all exported functions are considered as part of the public API. The private API is not mature yet, expect it to change.","category":"page"},{"location":"api/#Representing-a-point-cloud-1","page":"API","title":"Representing a point cloud","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"RANSACCloud\nRANSACCloud(vertices, normals, numofsubsets::Int)\nRANSACCloud(vertices, normals, subsets)","category":"page"},{"location":"api/#RANSAC.RANSACCloud","page":"API","title":"RANSAC.RANSACCloud","text":"struct RANSACCloud{A<:AbstractArray, B<:AbstractArray, C<:AbstractArray}\n\nA struct to wrap a point cloud. Stores the vertices, the normals,     the octree of the vertices,     the subsets (as an array of arrays of vertice indexes),     an array to indicate if a point is part of an already extracted primitive,     the size of the point cloud (number of vertices),     the weight of each octree level (populated during the construction of the octree,     by copying the given element),     an array to store the sum of the score of already     extracted primitives for each octree level.\n\n\n\n\n\n","category":"type"},{"location":"api/#RANSAC.RANSACCloud-Tuple{Any,Any,Int64}","page":"API","title":"RANSAC.RANSACCloud","text":"RANSACCloud(vertices, normals, numofsubsets::Int)\n\nConstruct a RANSACCloud with numofsubsets number of random subsets. Vertices and normals are converted to array of SVectors.\n\nArguments\n\nvertices: an array of vertices.\nnormals: an array of surface normals.\nnumofsubsets::Int: number of subsets.\nforce_eltype::Union{Nothing,DataType}=nothing:   an element type can be forced for the normals and vertices   (in practice Float64 or Float32). If not specified,   the element type of the passed vertices and normals will be used.\n\n\n\n\n\n","category":"method"},{"location":"api/#RANSAC.RANSACCloud-Tuple{Any,Any,Any}","page":"API","title":"RANSAC.RANSACCloud","text":"RANSACCloud(vertices, normals, subsets; force_eltype::Union{Nothing,DataType}=nothing)\n\nConstruct a RANSACCloud with the given subsets. Vertices and normals are converted to array of SVectors.\n\nArguments\n\nvertices: an array of vertices.\nnormals: an array of surface normals.\nsubsets::Vector{Vector{Int}}: a list of indexes for each subset.\nforce_eltype::Union{Nothing,DataType}=nothing:   an element type can be forced for the normals and vertices   (in practice Float64 or Float32). If not specified,   the element type of the passed vertices and normals will be used.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"The above constructors copy the vertices and normals and convert them to arrays of SVectors. If you want to pass the arrays directly, without modification, you can use the following function:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"nomodRANSACCloud","category":"page"},{"location":"api/#RANSAC.nomodRANSACCloud","page":"API","title":"RANSAC.nomodRANSACCloud","text":"nomodRANSACCloud(vertices, normals, subsets)\n\nConstruct a RANSACCloud without touching the vertices, normals and subsets. Other fields are computed.\n\nArguments\n\nvertices: an array of vertices.\nnormals: an array of surface normals.\nsubsets::Vector{Vector{Int}}: a list of indexes for each subset.\n\n\n\n\n\n","category":"function"},{"location":"api/#Parameters-1","page":"API","title":"Parameters","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"For parameters nested named tuples are used, because it's easy to construct them, change their values or extend them. Earlier Parameters.jl was used, but I could not solve the extension part, then came the named tuples. You can construct it by hand, use the exported ransacparameters() function or load from a YAML file.","category":"page"},{"location":"api/#Structure-of-the-parameters-1","page":"API","title":"Structure of the parameters","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"The easiest way to construct the desired named tuple is to use the ransacparameters() function.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"ransacparameters","category":"page"},{"location":"api/#RANSAC.ransacparameters","page":"API","title":"RANSAC.ransacparameters","text":"ransacparameters(p::T=DEFAULT_PARAMETERS; kwargs...) where {T<:NamedTuple}\n\nConstruct a NamedTuple based on a previous one, defaulting to DEFAULT_PARAMETERS and override it with the kwargs. Check the docs and examples for more.\n\nExamples\n\njulia> p1 = ransacparameters()\n(iteration = (drawN = 3, minsubsetN = 15, prob_det = 0.9),\nplane = (ϵ = 0.3, α = 0.08726646259971647),\ncone = (ϵ = 0.3, α = 0.08726646259971647, minconeopang = 0.03490658503988659),\ncylinder = (ϵ = 0.3, α = 0.08726646259971647),\nsphere = (ϵ = 0.3, α = 0.08726646259971647, sphere_par = 0.1))\n\njulia> p2 = ransacparameters(p1; sphere=(ϵ=0.9, α=deg2rad(1),), plane=(ϵ=1.0,))\n(iteration = (drawN = 3, minsubsetN = 15, prob_det = 0.9),\nplane = (ϵ = 1.0, α = 0.08726646259971647),\ncone = (ϵ = 0.3, α = 0.08726646259971647, minconeopang = 0.03490658503988659),\ncylinder = (ϵ = 0.3, α = 0.08726646259971647),\nsphere = (ϵ = 0.9, α = 0.017453292519943295, sphere_par = 0.1))\n\n\n\n\n\nransacparameters(p::Array{T}; kwargs...) where {T<:UnionAll}\n\nConstruct a NamedTuple for a given types of shapes  using defaultparameters and override it with the kwargs. Check the docs and examples for more.\n\nExamples\n\njulia> p1 = ransacparameters([FittedSphere, FittedCylinder])\n(iteration = (drawN = 3, minsubsetN = 15, prob_det = 0.9,\nshape_types = UnionAll[FittedSphere, FittedCylinder], τ = 900, itermax = 1000,\nextract_s = :nofminset, terminate_s = :nofminset),\ncommon = (collin_threshold = 0.2, parallelthrdeg = 1.0),\nsphere = (ϵ = 0.3, α = 0.08726646259971647, sphere_par = 0.02),\ncylinder = (ϵ = 0.3, α = 0.08726646259971647))\n\njulia> p2 = ransacparameters([FittedSphere, FittedCylinder], sphere=(ϵ=0.01,), cylinder=(α=0.02,))\n(iteration = (drawN = 3, minsubsetN = 15, prob_det = 0.9,\nshape_types = UnionAll[FittedSphere, FittedCylinder], τ = 900, itermax = 1000,\nextract_s = :nofminset, terminate_s = :nofminset),\ncommon = (collin_threshold = 0.2, parallelthrdeg = 1.0),\nsphere = (ϵ = 0.01, α = 0.08726646259971647, sphere_par = 0.02),\ncylinder = (ϵ = 0.3, α = 0.02))\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"As the docstring shows, you can construct a new one based on an old one, and give keyword arguments that will overwrite the old values. Note, that the key-values that are in the keyword arguments will be overwritten, not the named tuple itself (so the values not listed in the keyword argument will not change).","category":"page"},{"location":"api/#","page":"API","title":"API","text":"As you can see in the above examples, the parameter must have two fields:iteration, common and the primitive types that you want to fit (sphere, plane, etc.). Note, that p.iteration.shape_types field controls which primitives are fitted. Another important thing regarding the ransacparameter() function, that the keyword named tuple must have a trailing comma, so this is good:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"p2 = ransacparameters([FittedSphere, FittedCylinder], sphere=(ϵ=0.01,))","category":"page"},{"location":"api/#","page":"API","title":"API","text":", but the following is NOT:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"p2 = ransacparameters([FittedSphere, FittedCylinder], sphere=(ϵ=0.01))","category":"page"},{"location":"api/#","page":"API","title":"API","text":"The ransacparameters() function uses the not exported default...parameters() function, whose docstrings describes which parameters control what:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"RANSAC.defaultcommonparameters\nRANSAC.defaultiterationparameters","category":"page"},{"location":"api/#RANSAC.defaultcommonparameters","page":"API","title":"RANSAC.defaultcommonparameters","text":"defaultcommonparameters()\n\nConstruct a NamedTuple with the default common parameters.\n\nExamples\n\njulia> defaultcommonparameters()\n(common = (collin_threshold = 0.2, parallelthrdeg = 1.0),)\n\nImplementation\n\nThis section describes the role of the common parameters.\n\ncollin_threshold: 3 points can be nearly collinear,   in some cases they must be filtered. See the code of:   fit(::Type{FittedPlane}, p, n, params).\nparallelthrdeg: threshold for two vectos being parallel, in degrees.   If abs(dot(a,b))>cosd(parallelthrdeg), a and b are considered to be parallel.\n\n\n\n\n\n","category":"function"},{"location":"api/#RANSAC.defaultiterationparameters","page":"API","title":"RANSAC.defaultiterationparameters","text":"defaultiterationparameters(shape_types)\n\nConstruct a named tuple with the default iteration parameters. shape_types is an array of FittedShapes, that controls which primitives you want to fit to the point cloud.\n\nExamples\n\njulia> RANSAC.defaultiterationparameters([FittedPlane])\n(iteration = (drawN = 3, minsubsetN = 15, prob_det = 0.9,\nshape_types = UnionAll[FittedPlane], τ = 900, itermax = 1000,\nextract_s = :nofminset, terminate_s = :nofminset),)\n\njulia> RANSAC.defaultiterationparameters([FittedPlane, FittedSphere, FittedCone])\n(iteration = (drawN = 3, minsubsetN = 15, prob_det = 0.9,\nshape_types = UnionAll[FittedPlane, FittedSphere, FittedCone], τ = 900, itermax = 1000,\nextract_s = :nofminset, terminate_s = :nofminset),)\n\nImplementation\n\ndrawN: number of points to be sampled (length of a minimal subset).\nminsubsetN: number of minimal sets sampled in one iteration.\nprob_det: probability of detection.\nτ: minimal shape size.\nitermax: maximum number of iteration.\nshape_types: shapes that are fitted to the point cloud (array of types).\nextract_s, terminate_s: they are for easier testing, do not delete or modify it.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"Check RANSAC.defaultshapeparameters as well.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"The defaultparameters function joins these together:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"RANSAC.defaultparameters","category":"page"},{"location":"api/#RANSAC.defaultparameters","page":"API","title":"RANSAC.defaultparameters","text":"defaultparameters(shape_types::Vector{T}) where {T}\n\nConstruct a NamedTuple with the given shape types and the default parameters.\n\nExamples\n\njulia> defaultparameters([FittedSphere, FittedPlane])\n(iteration = (drawN = 3, minsubsetN = 15, prob_det = 0.9,\nshape_types = UnionAll[FittedSphere, FittedPlane], τ = 900, itermax = 1000,\nextract_s = :nofminset, terminate_s = :nofminset),\ncommon = (collin_threshold = 0.2, parallelthrdeg = 1.0),\nsphere = (ϵ = 0.3, α = 0.08726646259971647, sphere_par = 0.02),\nplane = (ϵ = 0.3, α = 0.08726646259971647))\n\n\n\n\n\n","category":"function"},{"location":"api/#Construct-by-hand-1","page":"API","title":"Construct by hand","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"As parameters are plain named tuples, one can easily construct their own. The above functions make heavy use of the merge function. Check the code, if you wish.","category":"page"},{"location":"api/#Parse-from-YAML-file-1","page":"API","title":"Parse from YAML file","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"With the help of YAML.jl one can easily read the parameters from a YAML file. As shown below, you can specify which parameters you want to change (the others are going to be the default ones).","category":"page"},{"location":"api/#","page":"API","title":"API","text":"An example file (config.yml):","category":"page"},{"location":"api/#","page":"API","title":"API","text":"plane:\n  - ϵ: 0.1\n  - α: 0.01\n\nsphere:\n  - ϵ: 0.2\n  - α: 0.05\n  # parameter in sphere fitting\n  - sphere_par: 0.01\n\ncone:\n  - ϵ: 1.\n  - α: 3.14\n  # filter those cones, whose opening angle is less than `minconeopang` radians\n  - minconeopang: 1.\n\niteration:\n  # number of points to be sampled (length of a minimal subset)\n  - drawN: 9\n  # number of minimal sets sampled in one iteration\n  - minsubsetN: 2\n  # probability of detection\n  - prob_det: 0.999\n  # minimal shape size\n  - τ: 10000\n  # maximum number of iteration\n  - itermax: 100000\n  # shapes that are fitted to the point cloud\n  - shape_types:\n    - plane\n    - sphere\n    - cone\n\ncommon:\n  # threshold of two vectors being parallel (in degrees)\n  - parallelthrdeg: 0.5\n  # threshold of points being collinear\n  - collin_threshold: 0.3","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Then you can use the readconfig function to read the file:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"julia> readconfig(\"config.yml\")\n(iteration = (drawN = 9, minsubsetN = 2, prob_det = 0.999,\nshape_types = UnionAll[FittedPlane, FittedSphere, FittedCone], τ = 10000,\nitermax = 100000, extract_s = :nofminset, terminate_s = :nofminset),\ncommon = (collin_threshold = 0.3, parallelthrdeg = 0.5),\nplane = (ϵ = 0.1, α = 0.01), cone = (ϵ = 1.0, α = 3.14, minconeopang = 1.0),\ncylinder = (ϵ = 0.3, α = 0.08726646259971647),\nsphere = (ϵ = 0.2, α = 0.05, sphere_par = 0.01))","category":"page"},{"location":"api/#","page":"API","title":"API","text":"readconfig\nRANSAC.DEFAULT_PARAMETERS\nRANSAC.DEFAULT_SHAPE_DICT","category":"page"},{"location":"api/#RANSAC.readconfig","page":"API","title":"RANSAC.readconfig","text":"readconfig(fname; toextend=DEFAULT_PARAMETERS, shapedict=DEFAULT_SHAPE_DICT)\n\nRead a config file to a NamedTuple. A \"base\" ntuple is expected, that gets overwritten/extended with the values in the config file. A Dict{String,FittedShape} dictionary is also expected, that translates the string primitive types to julia types.\n\nArguments\n\nfname: name of the config file.\ntoextend=DEFAULT_PARAMETERS: a named tuple,   that will be overwritten/extended with the values from the config file.\nshapedict=DEFAULT_SHAPE_DICT: a dictionary that   translates the string primitive names to julia types.\n\n\n\n\n\n","category":"function"},{"location":"api/#RANSAC.DEFAULT_PARAMETERS","page":"API","title":"RANSAC.DEFAULT_PARAMETERS","text":"const DEFAULT_PARAMETERS =      defaultparameters([FittedPlane, FittedCone, FittedCylinder, FittedSphere])\n\n\n\n\n\n","category":"constant"},{"location":"api/#RANSAC.DEFAULT_SHAPE_DICT","page":"API","title":"RANSAC.DEFAULT_SHAPE_DICT","text":"const DEFAULT_SHAPE_DICT = Dict(\"plane\"=>FittedPlane,     \"cone\"=>FittedCone, \"cylinder\"=>FittedCylinder, \"sphere\"=>FittedSphere)\n\n\n\n\n\n","category":"constant"},{"location":"api/#Primitives-1","page":"API","title":"Primitives","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"FittedShape\nFittedPlane\nFittedSphere\nFittedCylinder\nFittedCone","category":"page"},{"location":"api/#RANSAC.FittedShape","page":"API","title":"RANSAC.FittedShape","text":"An abstract type that supertypes all the fitted shapes.\n\n\n\n\n\n","category":"type"},{"location":"api/#RANSAC.FittedPlane","page":"API","title":"RANSAC.FittedPlane","text":"struct FittedPlane{A<:AbstractArray} <: FittedShape\n\nPlane primitive, defined by one of its point, and its normalvector.\n\n\n\n\n\n","category":"type"},{"location":"api/#RANSAC.FittedSphere","page":"API","title":"RANSAC.FittedSphere","text":"struct FittedSphere{A<:AbstractArray, R<:Real} <: FittedShape\n\nSphere primitive, defined by its center and radius. Also stored, if the normals point outwards of the shape.\n\n\n\n\n\n","category":"type"},{"location":"api/#RANSAC.FittedCylinder","page":"API","title":"RANSAC.FittedCylinder","text":"struct FittedCylinder{A<:AbstractArray, R<:Real} <: FittedShape\n\nCylinder primitive, defined by its axis direction, a point that lies on its axis, and its radius. Also stored, if the normals point outwards of the shape.\n\n\n\n\n\n","category":"type"},{"location":"api/#RANSAC.FittedCone","page":"API","title":"RANSAC.FittedCone","text":"struct FittedCone{A<:AbstractArray, R<:Real} <: FittedShape\n\nCone primitive, defined by its apex, its axis (that points from the apex towards the opening), and its opening angle in radians. Also stored, if the normals point outwards of the shape.\n\n\n\n\n\n","category":"type"},{"location":"api/#Iteration-1","page":"API","title":"Iteration","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"The ransac() function does the iteration.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"ransac","category":"page"},{"location":"api/#RANSAC.ransac","page":"API","title":"RANSAC.ransac","text":"ransac(pc, params, setenabled; reset_rand = false)\n\nRun the RANSAC algorithm on a pointcloud with the given parameters.\n\nReturn the extracted primitives and the time it took to run the algorithm (in seconds).\n\nArguments\n\npc::RANSACCloud: the point cloud.\nparams::NamedTuple: parameters.\nsetenabled::Bool: if true: set every point to enabled.\nreset_rand::Bool=false: if true, resets the random seed with Random.seed!(1234)\n\n\n\n\n\nransac(pc, params; reset_rand = false)\n\nRun the RANSAC algorithm on a pointcloud with the given parameters.\n\nReturn the extracted primitives and the time it took to run the algorithm (in seconds).\n\nArguments\n\npc::RANSACCloud: the point cloud.\nparams::NamedTuple: parameters.\nreset_rand::Bool=false: if true, resets the random seed with Random.seed!(1234)\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"The iteration returns an array of ExtractedShape:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"ExtractedShape","category":"page"},{"location":"api/#RANSAC.ExtractedShape","page":"API","title":"RANSAC.ExtractedShape","text":"ExtractedShape{S<:FittedShape}\n\nStore an extraced primitive (FittedShape) and the points that belong to the shape as Vector{Int}.\n\nImplementation\n\nWhen constructing in a refit function, just call the constructor with: ExtractedShape(shape, compatible_points).\n\n\n\n\n\n","category":"type"},{"location":"api/#Exporting-the-results-1","page":"API","title":"Exporting the results","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"With the help of JSON.jl, the resulted shapes can be easily saved to JSON files. For this purpose, the exportJSON() function can be used. Note that io must be specified, the \"default\" fallback to stdout is not implemented.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"exportJSON","category":"page"},{"location":"api/#RANSAC.exportJSON","page":"API","title":"RANSAC.exportJSON","text":"printJSON(io::IO, s, indent)\n\nPrint a FittedShape, ExtractedShape or a vector of them to io as a JSON string. With indent given, it prints a representation with newlines and indents.\n\nArguments:\n\nio::IO: must be specified, use stdout for interactive purposes.\ns: a FittedShape, ExtractedShape or a vector of one of them.\nindent::Int: indentation level.\n\n\n\n\n\nprintJSON(io::IO, s)\n\nPrint a FittedShape, ExtractedShape or a vector of them to io as a compact JSON string.\n\nArguments:\n\nio::IO: must be specified, use stdout for interactive purposes.\ns: a FittedShape, ExtractedShape or a vector of one of them.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"A few examples:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"julia> using RANSAC, StaticArrays\n\njulia> s1 = FittedPlane(SVector(0,0,1.), SVector(12.5, 7, 24))\nFittedPlane{SArray{Tuple{3},Float64,1,3}}\nnormal: [12.5, 7.0, 24.0], point: [0.0, 0.0, 1.0]\n\njulia> exportJSON(stdout, s1)\n{\"point\":[0.0,0.0,1.0],\"normal\":[12.5,7.0,24.0],\"type\":\"plane\"}\n\njulia> exportJSON(stdout, s1, 2)\n{\n  \"point\": [\n    0.0,\n    0.0,\n    1.0\n  ],\n  \"normal\": [\n    12.5,\n    7.0,\n    24.0\n  ],\n  \"type\": \"plane\"\n}","category":"page"},{"location":"api/#","page":"API","title":"API","text":"It is advised to export shapes in an array for easier processing (though I'm not a JSON expert):","category":"page"},{"location":"api/#","page":"API","title":"API","text":"julia> exportJSON(stdout, [s1])\n{\"primitives\":[{\"point\":[0.0,0.0,1.0],\"normal\":[12.5,7.0,24.0],\"type\":\"plane\"}]}\n\njulia> exportJSON(stdout, [s1], 2)\n{\n  \"primitives\": [\n    {\n      \"point\": [\n        0.0,\n        0.0,\n        1.0\n      ],\n      \"normal\": [\n        12.5,\n        7.0,\n        24.0\n      ],\n      \"type\": \"plane\"\n    }\n  ]\n}","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Works of course for different primitives:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"julia> s2 = FittedSphere(SVector(1.2, 3., 5.), 1.5, true)\nFittedSphere{SArray{Tuple{3},Float64,1,3}, Float64}\ncenter: [1.2, 3.0, 5.0], R: 1.5, outwards\n\njulia> exportJSON(stdout, [s1, s2], 2)\n{\n  \"primitives\": [\n    {\n      \"point\": [\n        0.0,\n        0.0,\n        1.0\n      ],\n      \"normal\": [\n        12.5,\n        7.0,\n        24.0\n      ],\n      \"type\": \"plane\"\n    },\n    {\n      \"outwards\": true,\n      \"radius\": 1.5,\n      \"center\": [\n        1.2,\n        3.0,\n        5.0\n      ],\n      \"type\": \"sphere\"\n    }\n  ]\n}","category":"page"},{"location":"api/#","page":"API","title":"API","text":"As can be seen above, in these cases an array of \"primitives\" is printed. Under the hood, the toDict() function does the job of converting the primitives to Dicts.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"RANSAC.toDict(s::FittedShape)\nRANSAC.toDict(::Vector{T}) where {T<:Union{FittedShape,ExtractedShape}}","category":"page"},{"location":"api/#RANSAC.toDict-Tuple{FittedShape}","page":"API","title":"RANSAC.toDict","text":"toDict(s::FittedShape)\n\nConvert s to a Dict{String,Any}. It's \"type\" is defined by strt. All fields of the struct is saved to the dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#RANSAC.toDict-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Union{FittedShape, ExtractedShape}","page":"API","title":"RANSAC.toDict","text":"toDict(a::Vector{T}) where {T<:Union{FittedShape,ExtractedShape}}\n\nConvert a vector of shapes to a Dict{String,Any}. The top key is a \"primitive\", whose value is the array of the shapes. See the documentation for examples.\n\n\n\n\n\n","category":"method"},{"location":"newprimitive/#Introducing-a-new-primitive-shape-1","page":"New primitive","title":"Introducing a new primitive shape","text":"","category":"section"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"warning: API under development\nThe primitive fitting API is still under development, so please be careful. If you have any issues, or questions, feel free to open issues/PR-s.","category":"page"},{"location":"newprimitive/#Fitting-API-1","page":"New primitive","title":"Fitting API","text":"","category":"section"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"If you want to extend the package with a new primitive, this page will guide you what to define/extend. You can also check the \"built-in\" primitives (´src/shapes/...´), which follow the same API.","category":"page"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"The primitive must be subtype of FittedShape (struct MyShape<:FittedShape), and you must define the following functions:","category":"page"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"defaultshapeparameters()\nfit()\nscorecandidate()\nrefit()\nstrt()","category":"page"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"Docs of the functions:","category":"page"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"RANSAC.defaultshapeparameters\nRANSAC.fit\nRANSAC.scorecandidate\nRANSAC.estimatescore\nRANSAC.refit\nRANSAC.strt","category":"page"},{"location":"newprimitive/#RANSAC.defaultshapeparameters","page":"New primitive","title":"RANSAC.defaultshapeparameters","text":"Return the default parameters as a NamedTuple for the passed FittedShape.\n\nImplementation\n\nExample definition for MyShape<:FittedShape: defaultshapeparameters(::Type{MyShape})=(myshape=(ϵ=1, α=deg2rad(5),),).\n\n\n\n\n\n","category":"function"},{"location":"newprimitive/#RANSAC.fit","page":"New primitive","title":"RANSAC.fit","text":"Fit a primitive shape to point-normal pairs (passed as an array of points and an array of normals). The type of the primitive and a parameter named tuple is also passed. The RANSACCloud is also passed if needed for more advanced methods. Return nothing, if can't fit the shape to the points.\n\nImplementation\n\nSignature: fit(::Type{MyShape}, p, n, pc, params).\n\nIt should return nothing if the fit wasn't succesfull, MyShape otherwise. If the fit results multiple shapes, it can return an array of MyShapes as well.\n\n\n\n\n\n","category":"function"},{"location":"newprimitive/#RANSAC.scorecandidate","page":"New primitive","title":"RANSAC.scorecandidate","text":"Compute the score of a candidate and return its score and the corresponding points.\n\nImplementation\n\nSignature: scorecandidate(pc, candidate::MyShape, subsetID, params).\n\nsubsetID is the index of the subset that is used to estimate the score. You must count the compatible points (that are enabled) in the given subset. You can get the points by: pc.vertices[pc.subsets[subsetID]] and normals similarly. Use the estimatescore function to estimate a score, then return a  (score, inpoints), where inpoints is the indexes of the points, that are counted.\n\n\n\n\n\n","category":"function"},{"location":"newprimitive/#RANSAC.estimatescore","page":"New primitive","title":"RANSAC.estimatescore","text":"estimatescore(S1length, Plength, σS1)\n\nGive an estimate score for the whole pointcloud.\n\nArguments\n\nS1length: number of points that are searched for compatible points (size of a subset).\nPlength: size of the whole point cloud.\nσS1: number of compatible points.\n\n\n\n\n\n","category":"function"},{"location":"newprimitive/#RANSAC.refit","page":"New primitive","title":"RANSAC.refit","text":"Refit a primitive to the whole point cloud, say search for all the compatible points in the point cloud.\n\nImplementation\n\nSignature: refit(s::T, pc, params) where {T<:MyShape}.\n\nSearch all the compatible (and enabled) points in the whole point cloud. After finding the indexes, return an ExtractedShape.\n\n\n\n\n\n","category":"function"},{"location":"newprimitive/#RANSAC.strt","page":"New primitive","title":"RANSAC.strt","text":"Return a string that tells the \"human-readable\" type (plane, spehere, etc.) of a FittedShape.\n\nImplementation\n\nstrt(s::MyShape) = \"myshape\"\n\n\n\n\n\n","category":"function"},{"location":"newprimitive/#Reading-parameters-from-YAML-file-1","page":"New primitive","title":"Reading parameters from YAML file","text":"","category":"section"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"If you want to read the parameters from a YAML file, you need to pass a dictionary to the readconfig function, that contains all the types, that you wish to use. If you have MyShape<:FittedShape and the following YAML file","category":"page"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"plane:\n  - ϵ: 0.1\n  - α: 0.01\n\nmyshape:\n  - ϵ: 0.1\n  - α: 0.01\n  - anotherpar: 42\n\niteration:\n  - prob_det: 0.999\n  - τ: 10000\n  - itermax: 100000\n  - shape_types:\n    - plane\n    - myshape","category":"page"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"you should use the following script to read the parameters:","category":"page"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"julia> myd = Dict(\"plane\"=>FittedPlane, \"myshape\"=>MyShape)\nDict{String,Type} with 2 entries:\n  \"plane\"   => FittedPlane\n  \"myshape\" => MyShape\n\njulia> p = readconfig(\"config.yml\", shapedict=myd)\n(iteration = (drawN = 3, minsubsetN = 15, prob_det = 0.999,\nshape_types = Type[FittedPlane, MyShape], τ = 10000, itermax = 100000,\nextract_s = :nofminset, terminate_s = :nofminset),\ncommon = (collin_threshold = 0.2, parallelthrdeg = 1.0),\nplane = (ϵ = 0.1, α = 0.01),\ncone = (ϵ = 0.3, α = 0.08726646259971647, minconeopang = 0.03490658503988659),\ncylinder = (ϵ = 0.3, α = 0.08726646259971647),\nsphere = (ϵ = 0.3, α = 0.08726646259971647, sphere_par = 0.02),\nmyshape = (ϵ = 0.1, α = 0.01, anotherpar = 42))","category":"page"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"The parameters for MyShape can be accessed with p.myshape. In any functions you need, the @extract macro can help from the ExtractMacro.jl package.","category":"page"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"An example:","category":"page"},{"location":"newprimitive/#","page":"New primitive","title":"New primitive","text":"function fit(::Type{MyShape}, p, n, params)\n    @extract params: params_myshape=myshape\n    @extract params_myshape : α, anotherpar\n    # you can use α, anotherpar as you wish\n    ...\nend","category":"page"},{"location":"#RANSAC.jl-1","page":"Home","title":"RANSAC.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package implements the efficient RANSAC algorithm for point clouds. Paper can be found here: Schnabel2007.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"R. Schnabel, R. Wahl, R. Klein \t\"Efficient RANSAC for Point-Cloud Shape Detection\", \tin Computer Graphics Forum, Vol. 26, No. 2, pages 214-226, \tBlackwell Publishing, June 2007","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A full page (Efficient RANSAC) is dedicated to describe the algorithm and to help to understand the parameters. If something is not clear, please open an issue or check the original paper.","category":"page"},{"location":"#Quick-tour-1","page":"Home","title":"Quick tour","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The efficient RANSAC algorithm is used to segment and fit primitive shapes (sphere, plane, cylinder, torus, cone) to point clouds. Up to now mostly C++ and Python implementations have been published, this is the first one in Julia (as far as I know).","category":"page"},{"location":"#Main-features-1","page":"Home","title":"Main features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"easy-to-use primitive recognition\nextensible: it's easy to add new primitive shapes\nfast (to be honest, it's not yet comparable with the reference and PCL implementations)","category":"page"},{"location":"#Differences-from-the-reference-implementation-1","page":"Home","title":"Differences from the reference implementation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"no bitmap\nseparate parameters for each shape\nno tori","category":"page"},{"location":"#Install-the-package-1","page":"Home","title":"Install the package","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"] add https://github.com/cserteGT3/RANSAC.jl","category":"page"},{"location":"#Load-a-point-cloud-1","page":"Home","title":"Load a point cloud","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Get an example point cloud. Use your own, or download a public dataset (for example the one used in Schnabel2009, read more about on the Example page) You can use MeshIO.jl to load models.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using FileIO\nm = load(\"testm.obj\")","category":"page"},{"location":"#Construct-a-RANSACCloud-1","page":"Home","title":"Construct a RANSACCloud","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using RANSAC\npc = RANSACCloud(m.position, m.normals, 2)\nrparams = ransacparameters()","category":"page"},{"location":"#Run-the-iteration-1","page":"Home","title":"Run the iteration","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"extr, _ = ransac(pc, rparams, true);","category":"page"},{"location":"#","page":"Home","title":"Home","text":"See the Example page for a detailed tour.","category":"page"},{"location":"#Short-algorithm-description-1","page":"Home","title":"Short algorithm description","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The input of the algorithm is a point cloud of size N with points and associated surface normals. The output is a set of primitive shapes with corresponding sets of points, and the rest of the points that do not belong to any primitives. Primitive shapes can be: plane, sphere, cylinder, cone and torus (though torus is not implemented yet).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In every iteration, new shape candidates are created by fitting primitives to randomly sampled minimal sets. Every shape primitive is generated for every minimal set and the valid ones are continuously collected in set C. Then every candidate is scored and the one with the highest score is considered the best. A candidate is only extracted if the probability (p_t) that no better candidates are in C is high enough. If the best candidate is chosen to be extracted, its points are removed from the point cloud, and every other candidate that has a removed point is also deleted from C. The iteration continues until the probability that every at least tau sized shape is found is larger than a parameter threshold. The score of a candidate is defined by the number of compatible points. A point is compatible if it is in the epsilon band of the shape, and its normal does not deviate from the surface normal more than an alpha angle. Also, only those points are considered that count towards the largest connecting component in the parameter space bitmap of the shape.","category":"page"},{"location":"example/#Example-1","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"This page guides you through the use of RANSAC.jl. A public dataset is used, that was published by Schnabel et al.and is accessible here.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"R. Schnabel, P. Degener, R. Klein \"Completion and Reconstruction with Primitive Shapes\", in Computer Graphics Forum (Proc. of Eurographics), Vol. 28, No. 2, pages 503-512","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"Read the algorithm description here to get a full understanding of the algorithm and its parameters.","category":"page"},{"location":"example/#Loading-the-data-1","page":"Example","title":"Loading the data","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"As MeshIO and other softwares had troubles opening the _input.obj files, I used MeshLab to open them and export to non-binary encoded PLY.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> using FileIO\n\njulia> m = load(\"fandisk_input.obj\");","category":"page"},{"location":"example/#Constructing-a-RANSACCloud-1","page":"Example","title":"Constructing a RANSACCloud","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"Currently the package only handles vectors of Float64.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> using RANSAC\n\njulia> pc = RANSACCloud(m.position, m.normals, 8);","category":"page"},{"location":"example/#Set-the-parameters-1","page":"Example","title":"Set the parameters","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"Check the Short algorithm description and Parameters pages to understand the parameters.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> p = ransacparameters()\n(iteration = (drawN = 3, minsubsetN = 15, prob_det = 0.9,\nshape_types = UnionAll[FittedPlane, FittedCone, FittedCylinder, FittedSphere],\nτ = 900, itermax = 1000, extract_s = :nofminset, terminate_s = :nofminset),\ncommon = (collin_threshold = 0.2, parallelthrdeg = 1.0),\nplane = (ϵ = 0.3, α = 0.08726646259971647),\ncone = (ϵ = 0.3, α = 0.08726646259971647, minconeopang = 0.03490658503988659),\ncylinder = (ϵ = 0.3, α = 0.08726646259971647),\nsphere = (ϵ = 0.3, α = 0.08726646259971647, sphere_par = 0.02))\n\njulia> newparams = (ϵ=0.05, α=deg2rad(10),)\n(ϵ = 0.05, α = 0.17453292519943295)\n\njulia> p = ransacparameters(p, sphere=newparams, cone=newparams, plane=newparams, cylinder=newparams, iteration=(τ=50, itermax=100_000,))\n(iteration = (drawN = 3, minsubsetN = 15, prob_det = 0.9,\nshape_types = UnionAll[FittedPlane, FittedCone, FittedCylinder, FittedSphere],\nτ = 50, itermax = 100000, extract_s = :nofminset, terminate_s = :nofminset),\ncommon = (collin_threshold = 0.2, parallelthrdeg = 1.0),\nplane = (ϵ = 0.05, α = 0.17453292519943295),\ncone = (ϵ = 0.05, α = 0.17453292519943295, minconeopang = 0.03490658503988659),\ncylinder = (ϵ = 0.05, α = 0.17453292519943295),\nsphere = (ϵ = 0.05, α = 0.17453292519943295, sphere_par = 0.02))","category":"page"},{"location":"example/#Run!-1","page":"Example","title":"Run!","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"The ransac() function runs the iteration.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> extr, _ = ransac(pc, p, true, reset_rand=true);","category":"page"},{"location":"example/#See-the-results-1","page":"Example","title":"See the results","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"The RANSACVisualizer package provides a few utility functions to check the results (check the docs for function signatures).","category":"page"},{"location":"example/#Check-the-input-1","page":"Example","title":"Check the input","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"The showgeometry() function shows a mesh and its normal vectors:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> showgeometry(m, arrow=0.3; show_axis = false)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/#Results-colored-randomly-1","page":"Example","title":"Results colored randomly","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"The showshapes() function provides this functionality.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> showshapes(pc, extr; show_axis = false)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/#Results-colored-according-to-their-type-1","page":"Example","title":"Results colored according to their type","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"The showbytype() function provides this functionality.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> showbytype(pc, extr; show_axis = false)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"(Image: )","category":"page"}]
}
